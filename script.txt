Theory

Ray tracing
Ray tracing is a rendering technique that is used to simulate realistic lighting in each scene by creating accurate reflections, 
refractions, shadows and indirect lighting.
Ray tracing generates a path from the view of a camera, through the 2D viewing plane into a 3D scene.
Can be inaccurate from the real world due to computational limits with modern-day computers.

Parallel programming
Parallel computing is the simultaneous use of multiple resources or threads within a computer to solve a problem.
A problem can be broken into discrete parts to be solved concurrently; Instructions from each part can be executed simultaneously on different cores.
Mutexs are used to prevent simultaneous editing of the same data, possibly causing a race condition.


Design - Aspects used in my code

Multi-bounce reflections
Reflections can be added to any given surface in the scene to create a new ray based on the reflective angle. 
On collision with the next object, the shade can be recalculated and returned to be added to the original intersected object.

The rayTrace function I created is used to calculate the shade of a given spot on the intersection, 
this function can be run in recursion for each bounce from the reflection.

Multithreading/thread pooling
Within my code threads can be created based on either user inputted value or based on the maximum the given system supports. 
Threads are assigned jobs to render one column of the screen at a time, 
thread pooling means no matter which order they finish their tasks they can take the next column that needs to be processed, 
increasing efficiency compared to assigning certain areas to each thread.

Soft shadows
I grab random points within a sphere from my light sources to sample rays towards the light, 
this means I can get areas of the shadow that can partly see the light.

For each ray that does not collide with an object and instead makes it to the light a proportion of its original colour will be added back in steps.

Global Illumination
Recursively using my traceRay function, I can return the shade of a random point shot out from a sphere's hemisphere in a direction to return an indirect lightings impact on the given point.

For a greater level of realism this would need a larger number of iterations to sample, otherwise this could end up being very noisy.

Anti-aliasing
Looping the main rayTracer with slight variations from the original pixel position to smooth out and average a colour.
Doing so will remove sharp edges off of objects and multiply any used techniques through the ray tracer increasing end quality.


Analysis

What data I collected and how:
I recorded a variety of different time-based tests for my program. I found that running these tests best helped see the impact of each calculation made with every loop. I can also test to see what result would visually be best without having an expensive computation time. 
I recorded this data by saving the time before the program started then after when the picture is rendered to the screen. Then i simply wrote the gathered data from each iteration of the program into a csv file, I decided to use excel to save my data as it would be simple to analysis and compare results. 

graph 1
Graph one shows that a linear increase in anti-aliasing samples also creates a linear progression in computation time. Within my ray tracer, 
the anti-aliasing sample direction increases the amount of times the most computationally heavy function is called. This function is found higher up
in the hierarchy of function calls. 

graph 2
Graph two shows that a linear increase in the number of threads assigned results in an exponential reduction in computational time, these results could likely be due to the use of mutexs 
within my multi-threading. As it requires a system call that involves a context switch on the operating system, this is inherently a fairly expensive operation.

graph 3
Graph three shows the correlation between time taken and the increase in global illumination iterations. Just as graph one has a linear increase in time so does this increase in samples, Global illumination sits within the ray tracing function meaning as it iterates it has less of an impact on the overall computation time.


Qualitative data
Gathered two reference images to test my program against.

The first scene was to show off global illumination at work, the main differences between the final outcomes is the reference image has matt objects that dont have specular lighting applied, where as all my objects in the scene are shiny to a certain degree. 
The reference image also uses a box light compared to my theoretical spherical light, this causes their scene to look more realistic and have an overall brighter final look.

For my second reference image i wanted to focus on multiple objects in the scene to show off reflectivity. 
The reference image has fewer features shown off, otherwise the main differences can be found in the genral lighting of the scene. 
Where as the reference image has better shadows and more natural lighting, my reflectivity in the mirror sphere is more realstic as I taken shading into account, also dimming the light coming in.


Evaluation

Overall, my ray tracer has many different features and tools to change how the scene can look.

Kept the ray tracer dynamic so no matter how the scene will be set up the program will always render as itâ€™s supposed to.

The program is an offline ray tracer that utilizes the CPU for its computation; this causes the program to run on very low variable samples to only get a couple frames per second.

The use of a recursive trace ray function to return the shade of an intersect came in very useful when needing to calculate reflections and global illumination.

The test data has shown me that the use of thread pool and multithreading is vital when using a heavy computational program.

Through out my features and calculations I made sure to use less computational heavy algorithms over others for effeciency. I found cheaper algorithms for exmaple my random point in a sphere avoids using arccosin as this is expensive for the computer, while still getting a visualy identical result.

What i would do different if I was to remake or go further with my ray tracer.
I would add refraction as an option for spheres to add an extra layer of realism to the scene.
I would also try to make the program render by utilizing the GPU for a much faster frame rate and at a higher quality.




